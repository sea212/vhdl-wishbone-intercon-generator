\documentclass{article}

% -----------------------------------------------------------------------------
% Fonts and typesetting settings
%------------------------------------------------------------------------------
%\usepackage{avant}
\usepackage{bookman}
\usepackage[T1]{fontenc}
\linespread{1.05} % Palatino needs more space between lines
%\usepackage{microtype}
\usepackage{amsmath}
\renewcommand{\familydefault}{\sfdefault}

%------------------------------------------------------------------------------
% Page layout
%------------------------------------------------------------------------------
\usepackage[hmarginratio=1:1,top=30mm,bottom=30mm,columnsep=20pt]{geometry}
\usepackage[font=it]{caption}
\usepackage{paralist}

\usepackage{graphicx}
\graphicspath{ {./footage/} }
\renewcommand{\figurename}{Abbildung}
\usepackage{color}
\usepackage{tabularx}

\usepackage{capt-of}

\usepackage[ngerman]{babel}

\usepackage{subcaption}
\usepackage{fancybox}
\renewcommand{\newline}{\leavevmode\newline}
%------------------------------------------------------------------------------
% Lettrines
%------------------------------------------------------------------------------
\usepackage{lettrine}

%------------------------------------------------------------------------------
% Abstract
%------------------------------------------------------------------------------
\usepackage{abstract}
	\renewcommand{\abstractnamefont}{\normalfont\bfseries}
	\renewcommand{\abstracttextfont}{\normalfont\small\itshape}

%------------------------------------------------------------------------------
% Titling (section/subsection)
%------------------------------------------------------------------------------
\usepackage{titlesec}

%------------------------------------------------------------------------------
% Header/footer
%------------------------------------------------------------------------------
\usepackage{fancyhdr}
	\pagestyle{fancy}
	\fancyhead{}
	\fancyfoot{}
	\fancyhead[C]{Hard- und Softwareschnittstellen $\bullet$ Wintersemester 15/16 $\bullet$ Prof. Dr. Steffen Reith}
	\fancyfoot[RO]{\thepage}

%------------------------------------------------------------------------------
% Maketitle metadata
%------------------------------------------------------------------------------
\title{\vspace{-3mm}%
	\fontsize{24pt}{10pt}\selectfont
	\textbf{VHDL Wishbone Intercon Generator} \\
	\textbf{Geschrieben in Python, generiert VHDL}
	}

\author{%
	\large
	\textsc{Harald Heckmann} \\[2mm]
	\normalsize	Studiengang Angewandte Informatik, Hochschule RheinMain \\
	\normalsize	Wintersemester 2015/2016 \\
	\normalsize	Projekt bei Prof. Dr. Steffen Reith \\
	\vspace{-5mm}
	}
\date{}

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{url}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%------------------------------------------------------------------------------
% Titelseite
%------------------------------------------------------------------------------

\maketitle
\newpage

%------------------------------------------------------------------------------
% Abstract und Inhaltsverzeichnis
%------------------------------------------------------------------------------



\begin{center}
\textbf{VHDL Wishbone Intercon Generator} \\
\textbf{Geschrieben in Python, generiert VHDL}
\end{center}

\begin{abstract}
Kurzfassung
\end{abstract}
\newpage
\tableofcontents
\newpage

%------------------------------------------------------------------------------
% Inhaltsseiten / Sections
%------------------------------------------------------------------------------

\section{Einleitung}
\subsection{Wishbone}
Wishbone ist ein Opensource Bussystem für System-on-Chip (SoC) Systeme.
Wishbone gibt ein Regelwerk vor, das bei der Entwicklung von IP-Cores
berücksichtigt werden kann, sodass alle Module, die diese Regeln berücksichtigen,
in der Lage sind bei geeigneter Verschaltung miteinander zu kommunizieren.
Die Teilnehmer eines Wishbone Bussystems werden in Master und Slave Kompontenten
unterteilt. Lediglich ein Master initiiert einen Datenaustausch und 
gibt dabei vor, ob es ein lesender oder schreibender Zugriff ist und an welcher Adresse
die Daten abgelegt oder ausgelesen werden. %Wishbone erlaubt Multimaster Systeme (mehrere Master Komponenten).%
Die Verschaltungseinheit, welche im weiteren Verlauf dieses Dokumentes mit dem Begriff \glqq Intercon\grqq referenziert wird, verschaltet bei einer Anfrage des Masters mit Hilfe der vom Master angegebenen Adresse 
dessen Leitungen mit den Leitungen des für die Adresse zuständigen Slaves.
\subsection{Aufgaben des Wishbone Intercon}
\begin{itemize}
\item Adressdekodierer - den für die angegebene Adresse zuständigen Slave wählen
\item (Nur bei Systemen mit mehreren Mastern) Ein Arbiter, der vom Benutzer definiert wird
\item Verbindung der Komponenten, sodass
\begin{itemize}
\item variable Adress- und Datenbusbreiten berücksichtigt werden
\item byte- und Wordadressierung berücksichtigt werden
\item bei unterschiedlicher Endianess eine Konvertierung durchgeführt wird
\end{itemize}
\end{itemize}
\subsection{Wishbone Beispiele}

\noindent
\shadowbox{%
\begin{minipage}{\dimexpr\textwidth-\shadowsize-2\fboxrule-2\fboxsep}
   \textcolor{red}{\sffamily Beispiel 1, Übungsszenario}\par\vspace{\baselineskip}
	[Master] Button-Controller \newline [Slave1] LED-Controller \newline [Slave2] RGB-LED-Controller
\end{minipage}}
\\\\
\noindent
\shadowbox{%
\begin{minipage}{\dimexpr\textwidth-\shadowsize-2\fboxrule-2\fboxsep}
   \textcolor{red}{\sffamily Beispiel 2, Reales Szenario}\par\vspace{\baselineskip}
	[Master] MCU \newline [Slave1] VGA-Controller \newline [Slave2] SRAM-Controller
\end{minipage}}

\section{Das Projekt}
Ziel des Projektes ist es, einen VHDL Code Generator zu erstellen,
der Informationen aus einer Konfigurationsdatei ausliest und aus
diesen Informationen einen geeigneten Wishbone Intercon in VHDL (Hardwarebeschreibungssprache) generiert.
Der Intercon soll in der Lage sein, einen Master und beliebig viele Slaves mit einer \glqq Point-to-Point Verbindung\grqq\ (1 Master, 1 Slave) oder einem \glqq Shared Bus\grqq\ (1 Master, n Slaves) zu verschalten.
\subsection{Projektaufbau}
Folgende Ordnerstruktur findet sich im Projektverzeichnis wieder:
\begin{itemize}
\item ./
\begin{itemize}
\item Beinhaltet die Python-Datei main.py, welche die Programmhauptroutine enthält.
\end{itemize}
\item cfg/
\begin{itemize}
\item Beinhaltet eine Konfigurationsdatei, aus der die Informationen für den Intercon entnommen werden
\end{itemize}
\item documentation/
\begin{itemize}
\item Beinhaltet diese Dokumentation
\end{itemize}
\item libs/
\begin{itemize}
\item Beinhaltet Python-Dateien, die dazu verwendet werden einen Wishbone Bus in Objekten zu abstrahieren als auch eine Konfigurationsdatei einzulesen und eine VHDL-Datei zu generieren
\end{itemize}
\item literature/
\begin{itemize}
\item Beinhaltet Literatur, die im laufe dieses Projektes verwendet wurde
\end{itemize}
\item vhdl/
\begin{itemize}
\item Beinhaltet Templatedateien (dazu später mehr) und die generierten VHDL-Dateien
\end{itemize}
\end{itemize}
\subsection{Aufgaben der einzelnen Module}
\paragraph{libs/wb\_component.py}\newline
enthält Wishbone Component klasse mit:
- wishbone componenten als superklasse
-> generelle informationen die sich master als auch slave teilen
-> unterklasse wishbone master mit masterspezifischen infos
-> unterklasse wishbone slave mit slavespezifischen infos
\paragraph{libs/wb\_intercon.py} 
enthält intercon klasse mit:
- generellen intercon infos
- einem master objekt (aus wb\_component->master)
- beliebig vielen slave objekten (aus wb\_component->slave)
\paragraph{libs/wb\_file\_manager.py} 
- parsen der config
- ausgabe der aus der konfiguration gelesenen und in intercon objekt eingetragenen werte
- generierung des intercon in VHDL
\paragraph{libs/main.py} 
- ausführen der funktionen in richtiger reinfolge
- exitstatus
- berechnungsdauer
\subsection{Aufbau der Konfigurationsdatei}
Erkläre sections, keys wurden bereits erklärt
\subsection{Arbeitsweise des Generators}
Der Generator verwendet ein WishboneIntercon Objekt (aus wb\_intercon.py), dass wie bereits bekannt alle notwendigen Informationen aus der Konfigurationsdatei enthält. Anschließend wird eine Templatedatei geöffnet, die den gesamten VHDL-Code und Platzhalter enthält. Einige Platzhalter werden immer durch Text ersetzt, da diese Zeilen im Template bei jeder Konfiguration im generierten VHDL Code enthalten sein werden. Nicht der gesamte VHDL Code kann so generiert werden, da es VHDL Code gibt der nur bei bestimmten Konfigurationen erzeugt wird (Beispielsweise 0-6 zusätzliche Signale) oder sich bei unterschiedlichen Konfigurationen unterscheidet (Beispielsweise Verschaltung der Datenleitung mit gleicher und unterschiedlicher Endianess). Der Code, der von der Struktur her nicht immer gleich bleibt, wird in Python (im Textsegment) erstellt und ersetzt anschließend die restlichen Platzhalter.
\subsubsection{VHDL Templates}
\paragraph{template\_intercon.tmpl}
wofür ist das gut?
\paragraph{template\_slave.tmpl}
wofür ist das gut?
\subsection{Programmfluss}
Alle Module mit Assoiziationspfeilen zeichen, module im nächsten kapitel erklären (AKTIVITÄTSDIAGRAMM?)\\
Dateipfade angeben

WICHTIG: Programm main.py muss mit python3 ausgeführt werden (NICHT python)
\subsection{Features}
Im folgenden werden die Funktionen des Intercon Generators dargelegt.
\subsubsection{Implementiert}
\subsubsection{Im Generator nicht Berücksichtigt}
Einige Konfigurationsmöglichkeiten werden mit in die Objekte (WishboneMaster, WishboneSlave, WishboneIntercon) übernommen, allerdings nicht vom Generator berücksichtigt. Dazu zählen:\\
Für Slaves:
\begin{itemize}
\item addressing\_granularity und word\_size\\
Beschreibt, in welchem Abstand Adressen angesprochen werden können.
Die addressing\_granularity kann byte oder word als Wert annehmen.
Sollte word ausgewählt sein, muss man den Konfigurationsparamter word\_size 
setzen, der den Abstand in Bits angibt. Beispiel (Adressraum: 0x0 - 0x100):\\
addressing\_granularity = byte, Adressen 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, etc. können angesprochen werden
addressing\_granularity = word und word\_size = 32, dann können Adressen in log2(32)=4er Schritten angesprochen werden : 0x0, 0x4, 0x8, etc.
\end{itemize}
Für Master und Slaves:
\begin{itemize}
\item data flow\\
Gibt an, ob eine Komponente auf den Datenbus nur lesen, nur schreiben oder lesen und schreiben darf
\end{itemize}
\subsubsection{Nachträglich entfernt}
\begin{itemize}
\item datatransfer
kann die Werte single, burst und rmw (read, modify, write) annehmen. Dieser Wert wurde auf Grund eines Missverständnisses zu Begin des Projektes anschließend im Verlauf des Projektes wieder entfernt, da das Verhalten des Intercon sich nicht dadurch beinflusst, ob die Daten einzelnt, mit bursts oder mittels rmw übertragen werden
\end{itemize}
\subsection{Probleme / Schwierigkeiten}
Ohne jemals etwas über die Arbeitsweise von Bussystemen gehört zu haben, ist es sehr Schwierig zu verstehen was in einem Wishbone Bussystem genau geschieht. Das offizielle Wishbone Referenzdokument \glqq Wishbone B4 \grqq war im laufe des Projektes die Hauptreferenzquelle. An der Stelle ist es wichtig zu erwähnen das der Autor des Dokuments hervorragende Arbeit geleistet hat. Schon Bald wurde klar, was in einem Wishbone Bussystem geschieht und wie die Komponenten miteinander kommunizieren, allerdings war eine lang anhaltende Schwierigkeit zu differenzen, welche Aufgaben in den Wishbone Modulen und welche Aufgaben in dem Wishbone Intercon durchgeführt werden. Hierbei hat sehr geholfen, sich bestehende Intercons anzuschauen und bereits bestehende Intercon Generatoren und deren generierten Code zu analyisieren. \\
Ein weitere Schwierigkeit ist es, mit einem Programm, das VHDL Quelltext generieren soll, einen rein kombinatorischen Schaltkreis ohne Latches zu erstellen. Da sich der generierte VHDL Code je nach Konfiguration verändert, verändern sich auch die Signalzuweisungen, die man zu beachten hat um den Schaltkreis kombinatorisch zu gestalten. Es ist in diesem Projekt nicht gelungen, einen Generator zu schreiben, der in allen Fällen einen VHDL Code generiert, welcher einen rein kombinatorischen Schaltkreis beschreibt.
\section{Schlusswort}
\paragraph{War die Vorgehensweise rückblickend gut?}
Die Vorgehensweise in Python einen Parser und Generator (in dieser Reihenfolge) zu schreiben, war weder eine besonders hervorragende, noch eine besonders schlechte Idee. Der Zusatzaufwand, der erforderlich ist um einen Parser und einen Generator zu schreiben, ist nicht außer acht zu lassen. Für diese Zwecke ist Python jedoch geeignet. Der Parser und der Generator machen den kleineren Teil aus, der größte Teil ist die Erstellung und Validierung der Objekte, bevor diese von der Generatorprozedur verwendet werden. Wäre das Projekt größer und der zu generierende Code von weiteren Bedingungen abhängig (= größeres Regelwerk für den Generator), so wird der Generator in Python unüberschaubar und nicht wartbar. Für einen Generator wie in diesem Pythonprojekt, der nur ein sehr kleines Regelwerk benötigt, wird es schon langsam unüberschaubar. Ohne Wissen über Compilerbau ist diese Vorgehensweise jedoch ein gutes Training, einen Teil der Probleme, die Generatoren zu behandeln haben, genauer kennen zu lernen.
Eine Alternative ist, bereits bestehende Code Generatoren zu verwenden, was einen wesentlichen Anteil and Programmcode spart und das Projekt leichter wartbar macht. Um einen solchen Generator genannt zu haben, \glqq GSL Universal Code Generator \grqq bietet die Möglichkeit \glqq Für alle Sprachen und alle Zwecke \grqq (Zitat aus der Dokumentation des Generators) Code zu generieren.
\paragraph{was lief gut?}
\paragraph{was lief schlecht?}
\paragraph{Bekannte Bugs}

Abschließend muss erwähnt werden, dass das Wissen das bei der Erstellung eines solchen Projektes über Parser, Generatoren, VHDL (oder) und vor allen Dingen Bussystemen, von großem Wert ist. Für das weitere Hardwarenahe Arbeiten ist das Wissen über Bussysteme von großer Bedeutung und beinahe unvermeidbar. Für das weitere Arbeiten mit FPGAs ist das Wissen über die Umsetzung von VHDL-Strukturen in Hardware von großer Wichtigkeit. Und Falls jemals wieder Code generiert werden muss, so ist nun klar, das nächstes mal ein Generatortool dafür verwendet wird oder ein spezielles Generatortool, erst nach Aneignung einigen Wissens über Compilerbau, entwickelt wird.
\end{document}
